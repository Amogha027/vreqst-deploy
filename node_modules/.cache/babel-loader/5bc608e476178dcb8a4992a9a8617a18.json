{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nimport { invariant } from '@react-dnd/invariant';\nimport { isObject } from '../../utils/js_utils.js';\nimport { DROP } from './types.js';\nexport function createDrop(manager) {\n  return function drop(options = {}) {\n    const monitor = manager.getMonitor();\n    const registry = manager.getRegistry();\n    verifyInvariants(monitor);\n    const targetIds = getDroppableTargets(monitor); // Multiple actions are dispatched here, which is why this doesn't return an action\n\n    targetIds.forEach((targetId, index) => {\n      const dropResult = determineDropResult(targetId, index, registry, monitor);\n      const action = {\n        type: DROP,\n        payload: {\n          dropResult: _objectSpread({}, options, dropResult)\n        }\n      };\n      manager.dispatch(action);\n    });\n  };\n}\n\nfunction verifyInvariants(monitor) {\n  invariant(monitor.isDragging(), 'Cannot call drop while not dragging.');\n  invariant(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');\n}\n\nfunction determineDropResult(targetId, index, registry, monitor) {\n  const target = registry.getTarget(targetId);\n  let dropResult = target ? target.drop(monitor, targetId) : undefined;\n  verifyDropResultType(dropResult);\n\n  if (typeof dropResult === 'undefined') {\n    dropResult = index === 0 ? {} : monitor.getDropResult();\n  }\n\n  return dropResult;\n}\n\nfunction verifyDropResultType(dropResult) {\n  invariant(typeof dropResult === 'undefined' || isObject(dropResult), 'Drop result must either be an object or undefined.');\n}\n\nfunction getDroppableTargets(monitor) {\n  const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);\n  targetIds.reverse();\n  return targetIds;\n}","map":{"version":3,"sources":["../../../src/actions/dragDrop/drop.ts"],"names":["invariant","isObject","DROP","createDrop","manager","drop","options","monitor","getMonitor","registry","getRegistry","verifyInvariants","targetIds","getDroppableTargets","forEach","targetId","index","dropResult","determineDropResult","action","type","payload","dispatch","isDragging","didDrop","target","getTarget","undefined","verifyDropResultType","getDropResult","getTargetIds","filter","canDropOnTarget","reverse"],"mappings":"AAAA,SAAA,eAAA,CAAA,GAAA,EAAA,GAAA,EAAA,KAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,SAAT,QAA0B,sBAA1B;AAUA,SAASC,QAAT,QAAyB,yBAAzB;AACA,SAASC,IAAT,QAAqB,YAArB;AAEA,OAAO,SAASC,UAAT,CAAoBC,OAApB,EAA8C;AACpD,SAAO,SAASC,IAAT,CAAcC,OAAO,GAAG,EAAxB,EAAkC;AACxC,UAAMC,OAAO,GAAGH,OAAO,CAACI,UAARJ,EAAhB;AACA,UAAMK,QAAQ,GAAGL,OAAO,CAACM,WAARN,EAAjB;AACAO,IAAAA,gBAAgB,CAACJ,OAAD,CAAhBI;AACA,UAAMC,SAAS,GAAGC,mBAAmB,CAACN,OAAD,CAArC,CAJwC,CAMxC;;AACAK,IAAAA,SAAS,CAACE,OAAVF,CAAkB,CAACG,QAAD,EAAWC,KAAX,KAAqB;AACtC,YAAMC,UAAU,GAAGC,mBAAmB,CAACH,QAAD,EAAWC,KAAX,EAAkBP,QAAlB,EAA4BF,OAA5B,CAAtC;AACA,YAAMY,MAAM,GAAwB;AACnCC,QAAAA,IAAI,EAAElB,IAD6B;AAEnCmB,QAAAA,OAAO,EAAE;AACRJ,UAAAA,UAAU,EAAE,aAAA,CAAA,EAAA,EACRX,OADQ,EAERW,UAFQ;AADJ;AAF0B,OAApC;AASAb,MAAAA,OAAO,CAACkB,QAARlB,CAAiBe,MAAjBf;AACA,KAZDQ;AAaA,GApBD;AAqBA;;AAED,SAASD,gBAAT,CAA0BJ,OAA1B,EAAoD;AACnDP,EAAAA,SAAS,CAACO,OAAO,CAACgB,UAARhB,EAAD,EAAuB,sCAAvB,CAATP;AACAA,EAAAA,SAAS,CACR,CAACO,OAAO,CAACiB,OAARjB,EADO,EAER,mDAFQ,CAATP;AAIA;;AAED,SAASkB,mBAAT,CACCH,QADD,EAECC,KAFD,EAGCP,QAHD,EAICF,OAJD,EAKE;AACD,QAAMkB,MAAM,GAAGhB,QAAQ,CAACiB,SAATjB,CAAmBM,QAAnBN,CAAf;AACA,MAAIQ,UAAU,GAAGQ,MAAM,GAAGA,MAAM,CAACpB,IAAPoB,CAAYlB,OAAZkB,EAAqBV,QAArBU,CAAH,GAAoCE,SAA3D;AACAC,EAAAA,oBAAoB,CAACX,UAAD,CAApBW;;AACA,MAAI,OAAOX,UAAP,KAAsB,WAA1B,EAAuC;AACtCA,IAAAA,UAAU,GAAGD,KAAK,KAAK,CAAVA,GAAc,EAAdA,GAAmBT,OAAO,CAACsB,aAARtB,EAAhCU;AACA;;AACD,SAAOA,UAAP;AACA;;AAED,SAASW,oBAAT,CAA8BX,UAA9B,EAA+C;AAC9CjB,EAAAA,SAAS,CACR,OAAOiB,UAAP,KAAsB,WAAtB,IAAqChB,QAAQ,CAACgB,UAAD,CADrC,EAER,oDAFQ,CAATjB;AAIA;;AAED,SAASa,mBAAT,CAA6BN,OAA7B,EAAuD;AACtD,QAAMK,SAAS,GAAGL,OAAO,CACvBuB,YADgBvB,GAEhBwB,MAFgBxB,CAETA,OAAO,CAACyB,eAFCzB,EAEgBA,OAFhBA,CAAlB;AAGAK,EAAAA,SAAS,CAACqB,OAAVrB;AACA,SAAOA,SAAP;AACA","sourcesContent":["import { invariant } from '@react-dnd/invariant'\n\nimport type {\n\tAction,\n\tDragDropManager,\n\tDragDropMonitor,\n\tDropPayload,\n\tHandlerRegistry,\n\tIdentifier,\n} from '../../interfaces.js'\nimport { isObject } from '../../utils/js_utils.js'\nimport { DROP } from './types.js'\n\nexport function createDrop(manager: DragDropManager) {\n\treturn function drop(options = {}): void {\n\t\tconst monitor = manager.getMonitor()\n\t\tconst registry = manager.getRegistry()\n\t\tverifyInvariants(monitor)\n\t\tconst targetIds = getDroppableTargets(monitor)\n\n\t\t// Multiple actions are dispatched here, which is why this doesn't return an action\n\t\ttargetIds.forEach((targetId, index) => {\n\t\t\tconst dropResult = determineDropResult(targetId, index, registry, monitor)\n\t\t\tconst action: Action<DropPayload> = {\n\t\t\t\ttype: DROP,\n\t\t\t\tpayload: {\n\t\t\t\t\tdropResult: {\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\t...dropResult,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tmanager.dispatch(action)\n\t\t})\n\t}\n}\n\nfunction verifyInvariants(monitor: DragDropMonitor) {\n\tinvariant(monitor.isDragging(), 'Cannot call drop while not dragging.')\n\tinvariant(\n\t\t!monitor.didDrop(),\n\t\t'Cannot call drop twice during one drag operation.',\n\t)\n}\n\nfunction determineDropResult(\n\ttargetId: Identifier,\n\tindex: number,\n\tregistry: HandlerRegistry,\n\tmonitor: DragDropMonitor,\n) {\n\tconst target = registry.getTarget(targetId)\n\tlet dropResult = target ? target.drop(monitor, targetId) : undefined\n\tverifyDropResultType(dropResult)\n\tif (typeof dropResult === 'undefined') {\n\t\tdropResult = index === 0 ? {} : monitor.getDropResult()\n\t}\n\treturn dropResult\n}\n\nfunction verifyDropResultType(dropResult: any) {\n\tinvariant(\n\t\ttypeof dropResult === 'undefined' || isObject(dropResult),\n\t\t'Drop result must either be an object or undefined.',\n\t)\n}\n\nfunction getDroppableTargets(monitor: DragDropMonitor) {\n\tconst targetIds = monitor\n\t\t.getTargetIds()\n\t\t.filter(monitor.canDropOnTarget, monitor)\n\ttargetIds.reverse()\n\treturn targetIds\n}\n"]},"metadata":{},"sourceType":"module"}