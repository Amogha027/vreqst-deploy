{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/amogha/Documents/sem-6/btp-1/deploy/deployed/vreqst/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"/home/amogha/Documents/sem-6/btp-1/deploy/deployed/vreqst/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _toConsumableArray = require(\"/home/amogha/Documents/sem-6/btp-1/deploy/deployed/vreqst/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reconstructFieldPath = exports.selectUnknownFields = exports.selectFields = void 0;\n\nvar _ = require(\"lodash\");\n\nvar selectFields = function selectFields(req, fields, locations) {\n  return _(fields).flatMap(function (field) {\n    return _.flatMap(locations, function (location) {\n      return expandField(req, field, location);\n    });\n  }) // Avoid duplicates if multiple field selections would return the same field twice.\n  // E.g. with fields = ['*.foo', 'bar.foo'] and req.body = { bar: { foo: 1 }, baz: { foo: 2 } },\n  // the instance bla.foo would appear twice, and baz.foo once.\n  .uniqWith(isSameFieldInstance).value();\n};\n\nexports.selectFields = selectFields;\n\nfunction isSameFieldInstance(a, b) {\n  return a.path === b.path && a.location === b.location;\n}\n\nfunction expandField(req, field, location) {\n  var originalPath = field;\n  var pathToExpand = location === 'headers' ? field.toLowerCase() : field;\n  var paths = expandPath(req[location], pathToExpand, []);\n  return paths.map(function (path) {\n    var value = path === '' ? req[location] : _.get(req[location], path);\n    return {\n      location: location,\n      path: path,\n      originalPath: originalPath,\n      value: value\n    };\n  });\n}\n\nfunction expandPath(object, path, currPath) {\n  var segments = _.toPath(path);\n\n  if (!segments.length) {\n    // no more paths to traverse\n    return [reconstructFieldPath(currPath)];\n  }\n\n  var key = segments[0];\n  var rest = segments.slice(1);\n\n  if (object != null && !_.isObjectLike(object)) {\n    if (key === '**' && !rest.length) {\n      // globstar leaves are always selected\n      return [reconstructFieldPath(currPath)];\n    } // there still are paths to traverse, but value is a primitive, stop\n\n\n    return [];\n  } // Use a non-null value so that inexistent fields are still selected\n\n\n  object = object || {};\n\n  if (key === '*') {\n    return Object.keys(object).flatMap(function (key) {\n      return expandPath(object[key], rest, currPath.concat(key));\n    });\n  }\n\n  if (key === '**') {\n    return Object.keys(object).flatMap(function (key) {\n      var nextPath = currPath.concat(key);\n      var value = object[key];\n      var set = new Set([].concat(_toConsumableArray(expandPath(value, segments, nextPath)), _toConsumableArray(rest[0] === key ? expandPath(value, rest.slice(1), nextPath) : [])));\n      return _toConsumableArray(set);\n    });\n  }\n\n  return expandPath(object[key], rest, currPath.concat(key));\n}\n\nvar selectUnknownFields = function selectUnknownFields(req, knownFields, locations) {\n  var tree = {};\n  knownFields.map(function (field) {\n    var segments = field === '' ? [''] : _.toPath(field);\n    pathToTree(segments, tree);\n  });\n  var instances = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = locations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var location = _step.value;\n\n      if (req[location] != null) {\n        instances.push.apply(instances, _toConsumableArray(findUnknownFields(location, req[location], tree)));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return instances;\n};\n\nexports.selectUnknownFields = selectUnknownFields;\n\nfunction pathToTree(segments, tree) {\n  // Will either create or merge into existing branch for the current path segment\n  var branch = tree[segments[0]] || (tree[segments[0]] = {});\n\n  if (segments.length > 1) {\n    pathToTree(segments.slice(1), branch);\n  } else {\n    // Leaf value.\n    branch[''] = {};\n  }\n}\n/**\n * Performs a depth-first search for unknown fields in `value`.\n * The path to the unknown fields will be pushed to the `unknownFields` argument.\n *\n * Known fields must be passed via `tree`. A field won't be considered unknown if:\n * - its branch is validated as a whole; that is, it contains an empty string key (e.g `{ ['']: {} }`); OR\n * - its path is individually validated; OR\n * - it's covered by a wildcard (`*`).\n *\n * @returns the list of unknown fields\n */\n\n\nfunction findUnknownFields(location, value, tree) {\n  var treePath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var unknownFields = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var globstarBranch = tree['**'];\n\n  if (tree[''] || (globstarBranch === null || globstarBranch === void 0 ? void 0 : globstarBranch[''])) {\n    // The rest of the tree from here is covered by some validation chain\n    // For example, when the current treePath is `['foo', 'bar']` but `foo` is known\n    return unknownFields;\n  }\n\n  if (typeof value !== 'object') {\n    if (!treePath.length || globstarBranch) {\n      // This is either\n      // a. a req.body that isn't an object (e.g. `req.body = 'bla'`), and wasn't validated either\n      // b. a leaf value which wasn't the target of a globstar path, e.g. `foo.**.bar`\n      unknownFields.push({\n        path: reconstructFieldPath(treePath),\n        value: value,\n        location: location\n      });\n    }\n\n    return unknownFields;\n  }\n\n  var wildcardBranch = tree['*'];\n\n  for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    var keyBranch = tree[key];\n    var path = treePath.concat([key]);\n\n    if (!keyBranch && !wildcardBranch && !globstarBranch) {\n      // No trees cover this path, so it's an unknown one.\n      unknownFields.push({\n        path: reconstructFieldPath(path),\n        value: value[key],\n        location: location\n      });\n      continue;\n    }\n\n    var keyUnknowns = keyBranch ? findUnknownFields(location, value[key], keyBranch, path) : [];\n    var wildcardUnknowns = wildcardBranch ? findUnknownFields(location, value[key], wildcardBranch, path) : [];\n    var globstarUnknowns = globstarBranch ? findUnknownFields(location, value[key], _objectSpread(_defineProperty({}, '**', globstarBranch), globstarBranch), path) : []; // If any of the tested branches contain only known fields, then don't mark the fields not covered\n    // by the other branches to the list of unknown ones.\n    // For example, `foo` is more comprehensive than `foo.*.bar`.\n\n    if ((!keyBranch || keyUnknowns.length) && (!wildcardBranch || wildcardUnknowns.length) && (!globstarBranch || globstarUnknowns.length)) {\n      unknownFields.push.apply(unknownFields, _toConsumableArray(keyUnknowns).concat(_toConsumableArray(wildcardUnknowns), _toConsumableArray(globstarUnknowns)));\n    }\n  }\n\n  return unknownFields;\n}\n/**\n * Reconstructs a field path from a list of path segments.\n *\n * Most segments will be concatenated by a dot, for example `['foo', 'bar']` becomes `foo.bar`.\n * However, a numeric segment will be wrapped in brackets to match regular JS array syntax:\n *\n * ```\n * reconstructFieldPath(['foo', 0, 'bar']) // foo[0].bar\n * ```\n *\n * Segments which have a special character such as `.` will be wrapped in brackets and quotes,\n * which also matches JS syntax for objects with such keys.\n *\n * ```\n * reconstructFieldPath(['foo', 'bar.baz', 'qux']) // foo[\"bar.baz\"].qux\n * ```\n */\n\n\nfunction reconstructFieldPath(segments) {\n  return segments.reduce(function (prev, segment) {\n    var part = '';\n    segment = segment === '\\\\*' ? '*' : segment; // TODO: Handle brackets?\n\n    if (segment.includes('.')) {\n      // Special char key access\n      part = \"[\\\"\".concat(segment, \"\\\"]\");\n    } else if (/^\\d+$/.test(segment)) {\n      // Index access\n      part = \"[\".concat(segment, \"]\");\n    } else if (prev) {\n      // Object key access\n      part = \".\".concat(segment);\n    } else {\n      // Top level key\n      part = segment;\n    }\n\n    return prev + part;\n  }, '');\n}\n\nexports.reconstructFieldPath = reconstructFieldPath;","map":{"version":3,"sources":["/home/amogha/Documents/sem-6/btp-1/deploy/deployed/vreqst/node_modules/express-validator/src/field-selection.js"],"names":["Object","defineProperty","exports","value","reconstructFieldPath","selectUnknownFields","selectFields","_","require","req","fields","locations","flatMap","field","location","expandField","uniqWith","isSameFieldInstance","a","b","path","originalPath","pathToExpand","toLowerCase","paths","expandPath","map","get","object","currPath","segments","toPath","length","key","rest","slice","isObjectLike","keys","concat","nextPath","set","Set","knownFields","tree","pathToTree","instances","push","findUnknownFields","branch","treePath","unknownFields","globstarBranch","wildcardBranch","keyBranch","keyUnknowns","wildcardUnknowns","globstarUnknowns","reduce","prev","segment","part","includes","test"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reconstructFieldPath = exports.selectUnknownFields = exports.selectFields = void 0;\nconst _ = require(\"lodash\");\nconst selectFields = (req, fields, locations) => _(fields)\n    .flatMap(field => _.flatMap(locations, location => {\n    return expandField(req, field, location);\n}))\n    // Avoid duplicates if multiple field selections would return the same field twice.\n    // E.g. with fields = ['*.foo', 'bar.foo'] and req.body = { bar: { foo: 1 }, baz: { foo: 2 } },\n    // the instance bla.foo would appear twice, and baz.foo once.\n    .uniqWith(isSameFieldInstance)\n    .value();\nexports.selectFields = selectFields;\nfunction isSameFieldInstance(a, b) {\n    return a.path === b.path && a.location === b.location;\n}\nfunction expandField(req, field, location) {\n    const originalPath = field;\n    const pathToExpand = location === 'headers' ? field.toLowerCase() : field;\n    const paths = expandPath(req[location], pathToExpand, []);\n    return paths.map(path => {\n        const value = path === '' ? req[location] : _.get(req[location], path);\n        return {\n            location,\n            path,\n            originalPath,\n            value,\n        };\n    });\n}\nfunction expandPath(object, path, currPath) {\n    const segments = _.toPath(path);\n    if (!segments.length) {\n        // no more paths to traverse\n        return [reconstructFieldPath(currPath)];\n    }\n    const key = segments[0];\n    const rest = segments.slice(1);\n    if (object != null && !_.isObjectLike(object)) {\n        if (key === '**' && !rest.length) {\n            // globstar leaves are always selected\n            return [reconstructFieldPath(currPath)];\n        }\n        // there still are paths to traverse, but value is a primitive, stop\n        return [];\n    }\n    // Use a non-null value so that inexistent fields are still selected\n    object = object || {};\n    if (key === '*') {\n        return Object.keys(object).flatMap(key => expandPath(object[key], rest, currPath.concat(key)));\n    }\n    if (key === '**') {\n        return Object.keys(object).flatMap(key => {\n            const nextPath = currPath.concat(key);\n            const value = object[key];\n            const set = new Set([\n                // recursively find matching subpaths\n                ...expandPath(value, segments, nextPath),\n                // skip the first remaining segment, if it matches the current key\n                ...(rest[0] === key ? expandPath(value, rest.slice(1), nextPath) : []),\n            ]);\n            return [...set];\n        });\n    }\n    return expandPath(object[key], rest, currPath.concat(key));\n}\nconst selectUnknownFields = (req, knownFields, locations) => {\n    const tree = {};\n    knownFields.map(field => {\n        const segments = field === '' ? [''] : _.toPath(field);\n        pathToTree(segments, tree);\n    });\n    const instances = [];\n    for (const location of locations) {\n        if (req[location] != null) {\n            instances.push(...findUnknownFields(location, req[location], tree));\n        }\n    }\n    return instances;\n};\nexports.selectUnknownFields = selectUnknownFields;\nfunction pathToTree(segments, tree) {\n    // Will either create or merge into existing branch for the current path segment\n    const branch = tree[segments[0]] || (tree[segments[0]] = {});\n    if (segments.length > 1) {\n        pathToTree(segments.slice(1), branch);\n    }\n    else {\n        // Leaf value.\n        branch[''] = {};\n    }\n}\n/**\n * Performs a depth-first search for unknown fields in `value`.\n * The path to the unknown fields will be pushed to the `unknownFields` argument.\n *\n * Known fields must be passed via `tree`. A field won't be considered unknown if:\n * - its branch is validated as a whole; that is, it contains an empty string key (e.g `{ ['']: {} }`); OR\n * - its path is individually validated; OR\n * - it's covered by a wildcard (`*`).\n *\n * @returns the list of unknown fields\n */\nfunction findUnknownFields(location, value, tree, treePath = [], unknownFields = []) {\n    const globstarBranch = tree['**'];\n    if (tree[''] || globstarBranch?.['']) {\n        // The rest of the tree from here is covered by some validation chain\n        // For example, when the current treePath is `['foo', 'bar']` but `foo` is known\n        return unknownFields;\n    }\n    if (typeof value !== 'object') {\n        if (!treePath.length || globstarBranch) {\n            // This is either\n            // a. a req.body that isn't an object (e.g. `req.body = 'bla'`), and wasn't validated either\n            // b. a leaf value which wasn't the target of a globstar path, e.g. `foo.**.bar`\n            unknownFields.push({\n                path: reconstructFieldPath(treePath),\n                value,\n                location,\n            });\n        }\n        return unknownFields;\n    }\n    const wildcardBranch = tree['*'];\n    for (const key of Object.keys(value)) {\n        const keyBranch = tree[key];\n        const path = treePath.concat([key]);\n        if (!keyBranch && !wildcardBranch && !globstarBranch) {\n            // No trees cover this path, so it's an unknown one.\n            unknownFields.push({\n                path: reconstructFieldPath(path),\n                value: value[key],\n                location,\n            });\n            continue;\n        }\n        const keyUnknowns = keyBranch ? findUnknownFields(location, value[key], keyBranch, path) : [];\n        const wildcardUnknowns = wildcardBranch\n            ? findUnknownFields(location, value[key], wildcardBranch, path)\n            : [];\n        const globstarUnknowns = globstarBranch\n            ? findUnknownFields(location, value[key], { ['**']: globstarBranch, ...globstarBranch }, path)\n            : [];\n        // If any of the tested branches contain only known fields, then don't mark the fields not covered\n        // by the other branches to the list of unknown ones.\n        // For example, `foo` is more comprehensive than `foo.*.bar`.\n        if ((!keyBranch || keyUnknowns.length) &&\n            (!wildcardBranch || wildcardUnknowns.length) &&\n            (!globstarBranch || globstarUnknowns.length)) {\n            unknownFields.push(...keyUnknowns, ...wildcardUnknowns, ...globstarUnknowns);\n        }\n    }\n    return unknownFields;\n}\n/**\n * Reconstructs a field path from a list of path segments.\n *\n * Most segments will be concatenated by a dot, for example `['foo', 'bar']` becomes `foo.bar`.\n * However, a numeric segment will be wrapped in brackets to match regular JS array syntax:\n *\n * ```\n * reconstructFieldPath(['foo', 0, 'bar']) // foo[0].bar\n * ```\n *\n * Segments which have a special character such as `.` will be wrapped in brackets and quotes,\n * which also matches JS syntax for objects with such keys.\n *\n * ```\n * reconstructFieldPath(['foo', 'bar.baz', 'qux']) // foo[\"bar.baz\"].qux\n * ```\n */\nfunction reconstructFieldPath(segments) {\n    return segments.reduce((prev, segment) => {\n        let part = '';\n        segment = segment === '\\\\*' ? '*' : segment;\n        // TODO: Handle brackets?\n        if (segment.includes('.')) {\n            // Special char key access\n            part = `[\"${segment}\"]`;\n        }\n        else if (/^\\d+$/.test(segment)) {\n            // Index access\n            part = `[${segment}]`;\n        }\n        else if (prev) {\n            // Object key access\n            part = `.${segment}`;\n        }\n        else {\n            // Top level key\n            part = segment;\n        }\n        return prev + part;\n    }, '');\n}\nexports.reconstructFieldPath = reconstructFieldPath;\n"]},"metadata":{},"sourceType":"script"}