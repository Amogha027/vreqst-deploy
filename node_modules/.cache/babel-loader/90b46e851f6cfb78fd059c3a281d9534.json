{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/amogha/btp/temp/VReqST-main/VReqST/frontend/client/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/amogha/btp/temp/VReqST-main/VReqST/frontend/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/amogha/btp/temp/VReqST-main/VReqST/frontend/client/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Context = void 0;\n\nvar _ = require(\"lodash\");\n\nfunction getDataMapKey(path, location) {\n  return \"\".concat(location, \":\").concat(path);\n}\n\nvar Context =\n/*#__PURE__*/\nfunction () {\n  function Context(fields, locations, stack, optional, message) {\n    _classCallCheck(this, Context);\n\n    this.fields = fields;\n    this.locations = locations;\n    this.stack = stack;\n    this.optional = optional;\n    this.message = message;\n    this._errors = [];\n    this.dataMap = new Map();\n  }\n\n  _createClass(Context, [{\n    key: \"getData\",\n    value: function getData() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        requiredOnly: false\n      };\n      // Have to store this.optional in a const otherwise TS thinks the value could have changed\n      // when the functions below run\n      var optional = this.optional;\n      var checks = options.requiredOnly && optional ? [function (value) {\n        return value !== undefined;\n      }, function (value) {\n        return optional.nullable ? value != null : true;\n      }, function (value) {\n        return optional.checkFalsy ? value : true;\n      }] : [];\n      return _(_toConsumableArray(this.dataMap.values())).groupBy('originalPath').flatMap(function (instances, group) {\n        var locations = _.uniqBy(instances, 'location'); // #331 - When multiple locations are involved, all of them must pass the validation.\n        // If none of the locations contain the field, we at least include one for error reporting.\n        // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n        // paths, so we may want to skip this filtering.\n\n\n        if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n          var withValue = instances.filter(function (instance) {\n            return instance.value !== undefined;\n          });\n          return withValue.length ? withValue : [instances[0]];\n        }\n\n        return instances;\n      }).filter(function (instance) {\n        return checks.every(function (check) {\n          return check(instance.value);\n        });\n      }).valueOf();\n    }\n  }, {\n    key: \"addFieldInstances\",\n    value: function addFieldInstances(instances) {\n      var _this = this;\n\n      instances.forEach(function (instance) {\n        _this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\n      });\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(path, value, location) {\n      var instance = this.dataMap.get(getDataMapKey(path, location));\n\n      if (!instance) {\n        throw new Error('Attempt to write data that did not pre-exist in context');\n      }\n\n      instance.value = value;\n    }\n  }, {\n    key: \"addError\",\n    value: function addError(message, valueOrNestedErrors, meta) {\n      var msg = message || this.message || 'Invalid value';\n\n      if (meta) {\n        this._errors.push({\n          value: valueOrNestedErrors,\n          msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\n          param: meta.path,\n          location: meta.location\n        });\n      } else {\n        this._errors.push({\n          msg: msg,\n          param: '_error',\n          nestedErrors: valueOrNestedErrors\n        });\n      }\n    }\n  }, {\n    key: \"errors\",\n    get: function get() {\n      return this._errors;\n    }\n  }]);\n\n  return Context;\n}();\n\nexports.Context = Context;","map":{"version":3,"sources":["/home/amogha/btp/temp/VReqST-main/VReqST/frontend/client/node_modules/express-validator/src/context.js"],"names":["Object","defineProperty","exports","value","Context","_","require","getDataMapKey","path","location","fields","locations","stack","optional","message","_errors","dataMap","Map","options","requiredOnly","checks","undefined","nullable","checkFalsy","values","groupBy","flatMap","instances","group","uniqBy","length","includes","withValue","filter","instance","every","check","valueOf","forEach","set","assign","get","Error","valueOrNestedErrors","meta","msg","push","param","nestedErrors"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Context = void 0;\nconst _ = require(\"lodash\");\nfunction getDataMapKey(path, location) {\n    return `${location}:${path}`;\n}\nclass Context {\n    constructor(fields, locations, stack, optional, message) {\n        this.fields = fields;\n        this.locations = locations;\n        this.stack = stack;\n        this.optional = optional;\n        this.message = message;\n        this._errors = [];\n        this.dataMap = new Map();\n    }\n    get errors() {\n        return this._errors;\n    }\n    getData(options = { requiredOnly: false }) {\n        // Have to store this.optional in a const otherwise TS thinks the value could have changed\n        // when the functions below run\n        const { optional } = this;\n        const checks = options.requiredOnly && optional\n            ? [\n                (value) => value !== undefined,\n                (value) => (optional.nullable ? value != null : true),\n                (value) => (optional.checkFalsy ? value : true),\n            ]\n            : [];\n        return _([...this.dataMap.values()])\n            .groupBy('originalPath')\n            .flatMap((instances, group) => {\n            const locations = _.uniqBy(instances, 'location');\n            // #331 - When multiple locations are involved, all of them must pass the validation.\n            // If none of the locations contain the field, we at least include one for error reporting.\n            // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n            // paths, so we may want to skip this filtering.\n            if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n                const withValue = instances.filter(instance => instance.value !== undefined);\n                return withValue.length ? withValue : [instances[0]];\n            }\n            return instances;\n        })\n            .filter(instance => checks.every(check => check(instance.value)))\n            .valueOf();\n    }\n    addFieldInstances(instances) {\n        instances.forEach(instance => {\n            this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\n        });\n    }\n    setData(path, value, location) {\n        const instance = this.dataMap.get(getDataMapKey(path, location));\n        if (!instance) {\n            throw new Error('Attempt to write data that did not pre-exist in context');\n        }\n        instance.value = value;\n    }\n    addError(message, valueOrNestedErrors, meta) {\n        const msg = message || this.message || 'Invalid value';\n        if (meta) {\n            this._errors.push({\n                value: valueOrNestedErrors,\n                msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\n                param: meta.path,\n                location: meta.location,\n            });\n        }\n        else {\n            this._errors.push({\n                msg,\n                param: '_error',\n                nestedErrors: valueOrNestedErrors,\n            });\n        }\n    }\n}\nexports.Context = Context;\n"]},"metadata":{},"sourceType":"script"}