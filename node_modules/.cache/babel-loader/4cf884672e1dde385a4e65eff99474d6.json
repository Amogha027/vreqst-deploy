{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/amogha/Documents/sem-6/btp-1/deploy/deployed/vreqst/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _toConsumableArray = require(\"/home/amogha/Documents/sem-6/btp-1/deploy/deployed/vreqst/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/amogha/Documents/sem-6/btp-1/deploy/deployed/vreqst/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/amogha/Documents/sem-6/btp-1/deploy/deployed/vreqst/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Context = void 0;\n\nvar _ = require(\"lodash\");\n\nfunction getDataMapKey(path, location) {\n  return \"\".concat(location, \":\").concat(path);\n}\n\nvar Context =\n/*#__PURE__*/\nfunction () {\n  function Context(fields, locations, stack, optional, bail, message) {\n    _classCallCheck(this, Context);\n\n    this.fields = fields;\n    this.locations = locations;\n    this.stack = stack;\n    this.optional = optional;\n    this.bail = bail;\n    this.message = message;\n    this._errors = [];\n    this.dataMap = new Map();\n  }\n\n  _createClass(Context, [{\n    key: \"getData\",\n    value: function getData() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        requiredOnly: false\n      };\n      var optional = this.optional;\n      var checks = options.requiredOnly && optional ? [function (value) {\n        return value !== undefined;\n      }, function (value) {\n        return optional === 'null' ? value != null : true;\n      }, function (value) {\n        return optional === 'falsy' ? value : true;\n      }] : [];\n      return _(_toConsumableArray(this.dataMap.values())).groupBy('originalPath').flatMap(function (instances, group) {\n        var locations = _.uniqBy(instances, 'location'); // #331 - When multiple locations are involved, all of them must pass the validation.\n        // If none of the locations contain the field, we at least include one for error reporting.\n        // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n        // paths, so we may want to skip this filtering.\n\n\n        if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n          var withValue = instances.filter(function (instance) {\n            return instance.value !== undefined;\n          });\n          return withValue.length ? withValue : [instances[0]];\n        }\n\n        return instances;\n      }).filter(function (instance) {\n        return checks.every(function (check) {\n          return check(instance.value);\n        });\n      }).valueOf();\n    }\n  }, {\n    key: \"addFieldInstances\",\n    value: function addFieldInstances(instances) {\n      var _this = this;\n\n      instances.forEach(function (instance) {\n        _this.dataMap.set(getDataMapKey(instance.path, instance.location), _objectSpread({}, instance));\n      });\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(path, value, location) {\n      var instance = this.dataMap.get(getDataMapKey(path, location));\n\n      if (!instance) {\n        throw new Error('Attempt to write data that did not pre-exist in context');\n      }\n\n      instance.value = value;\n    }\n  }, {\n    key: \"addError\",\n    value: function addError(opts) {\n      var _opts$meta, _opts$meta2;\n\n      var msg = opts.message || this.message || 'Invalid value';\n      var error;\n\n      switch (opts.type) {\n        case 'field':\n          error = {\n            type: 'field',\n            value: opts.value,\n            msg: typeof msg === 'function' ? msg(opts.value, opts.meta) : msg,\n            path: (_opts$meta = opts.meta) === null || _opts$meta === void 0 ? void 0 : _opts$meta.path,\n            location: (_opts$meta2 = opts.meta) === null || _opts$meta2 === void 0 ? void 0 : _opts$meta2.location\n          };\n          break;\n\n        case 'unknown_fields':\n          error = {\n            type: 'unknown_fields',\n            msg: typeof msg === 'function' ? msg(opts.fields, {\n              req: opts.req\n            }) : msg,\n            fields: opts.fields\n          };\n          break;\n\n        case 'alternative':\n          error = {\n            type: 'alternative',\n            msg: typeof msg === 'function' ? msg(opts.nestedErrors, {\n              req: opts.req\n            }) : msg,\n            nestedErrors: opts.nestedErrors\n          };\n          break;\n\n        case 'alternative_grouped':\n          error = {\n            type: 'alternative_grouped',\n            msg: typeof msg === 'function' ? msg(opts.nestedErrors, {\n              req: opts.req\n            }) : msg,\n            nestedErrors: opts.nestedErrors\n          };\n          break;\n\n        default:\n          throw new Error(\"Unhandled addError case\");\n      }\n\n      this._errors.push(error);\n    }\n  }, {\n    key: \"errors\",\n    get: function get() {\n      return this._errors;\n    }\n  }]);\n\n  return Context;\n}();\n\nexports.Context = Context;","map":{"version":3,"sources":["/home/amogha/Documents/sem-6/btp-1/deploy/deployed/vreqst/node_modules/express-validator/src/context.js"],"names":["Object","defineProperty","exports","value","Context","_","require","getDataMapKey","path","location","fields","locations","stack","optional","bail","message","_errors","dataMap","Map","options","requiredOnly","checks","undefined","values","groupBy","flatMap","instances","group","uniqBy","length","includes","withValue","filter","instance","every","check","valueOf","forEach","set","get","Error","opts","msg","error","type","meta","req","nestedErrors","push"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Context = void 0;\nconst _ = require(\"lodash\");\nfunction getDataMapKey(path, location) {\n    return `${location}:${path}`;\n}\nclass Context {\n    constructor(fields, locations, stack, optional, bail, message) {\n        this.fields = fields;\n        this.locations = locations;\n        this.stack = stack;\n        this.optional = optional;\n        this.bail = bail;\n        this.message = message;\n        this._errors = [];\n        this.dataMap = new Map();\n    }\n    get errors() {\n        return this._errors;\n    }\n    getData(options = { requiredOnly: false }) {\n        const { optional } = this;\n        const checks = options.requiredOnly && optional\n            ? [\n                (value) => value !== undefined,\n                (value) => (optional === 'null' ? value != null : true),\n                (value) => (optional === 'falsy' ? value : true),\n            ]\n            : [];\n        return _([...this.dataMap.values()])\n            .groupBy('originalPath')\n            .flatMap((instances, group) => {\n            const locations = _.uniqBy(instances, 'location');\n            // #331 - When multiple locations are involved, all of them must pass the validation.\n            // If none of the locations contain the field, we at least include one for error reporting.\n            // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n            // paths, so we may want to skip this filtering.\n            if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n                const withValue = instances.filter(instance => instance.value !== undefined);\n                return withValue.length ? withValue : [instances[0]];\n            }\n            return instances;\n        })\n            .filter(instance => checks.every(check => check(instance.value)))\n            .valueOf();\n    }\n    addFieldInstances(instances) {\n        instances.forEach(instance => {\n            this.dataMap.set(getDataMapKey(instance.path, instance.location), { ...instance });\n        });\n    }\n    setData(path, value, location) {\n        const instance = this.dataMap.get(getDataMapKey(path, location));\n        if (!instance) {\n            throw new Error('Attempt to write data that did not pre-exist in context');\n        }\n        instance.value = value;\n    }\n    addError(opts) {\n        const msg = opts.message || this.message || 'Invalid value';\n        let error;\n        switch (opts.type) {\n            case 'field':\n                error = {\n                    type: 'field',\n                    value: opts.value,\n                    msg: typeof msg === 'function' ? msg(opts.value, opts.meta) : msg,\n                    path: opts.meta?.path,\n                    location: opts.meta?.location,\n                };\n                break;\n            case 'unknown_fields':\n                error = {\n                    type: 'unknown_fields',\n                    msg: typeof msg === 'function' ? msg(opts.fields, { req: opts.req }) : msg,\n                    fields: opts.fields,\n                };\n                break;\n            case 'alternative':\n                error = {\n                    type: 'alternative',\n                    msg: typeof msg === 'function' ? msg(opts.nestedErrors, { req: opts.req }) : msg,\n                    nestedErrors: opts.nestedErrors,\n                };\n                break;\n            case 'alternative_grouped':\n                error = {\n                    type: 'alternative_grouped',\n                    msg: typeof msg === 'function' ? msg(opts.nestedErrors, { req: opts.req }) : msg,\n                    nestedErrors: opts.nestedErrors,\n                };\n                break;\n            default:\n                throw new Error(`Unhandled addError case`);\n        }\n        this._errors.push(error);\n    }\n}\nexports.Context = Context;\n"]},"metadata":{},"sourceType":"script"}