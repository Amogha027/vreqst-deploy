{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/amogha/btp/deploy/VReqST-2/VReqST-main/VReqST/frontend/client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/amogha/btp/deploy/VReqST-2/VReqST-main/VReqST/frontend/client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"/home/amogha/btp/deploy/VReqST-2/VReqST-main/VReqST/frontend/client/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkSchema = void 0;\n\nvar chain_1 = require(\"../chain\");\n\nvar check_1 = require(\"./check\");\n\nvar validLocations = ['body', 'cookies', 'headers', 'params', 'query'];\nvar protectedNames = ['errorMessage', 'in'];\n/**\n * Creates an express middleware with validations for multiple fields at once in the form of\n * a schema object.\n *\n * @param schema the schema to validate.\n * @param defaultLocations\n * @returns\n */\n\nfunction checkSchema(schema) {\n  var defaultLocations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : validLocations;\n  var chains = Object.keys(schema).map(function (field) {\n    var config = schema[field];\n    var chain = check_1.check(field, ensureLocations(config, defaultLocations), config.errorMessage);\n    Object.keys(config).filter(function (method) {\n      return config[method] && !protectedNames.includes(method);\n    }).forEach(function (method) {\n      var _a;\n\n      if (typeof chain[method] !== 'function') {\n        console.warn(\"express-validator: a validator/sanitizer with name \".concat(method, \" does not exist\"));\n        return;\n      } // Using \"!\" because typescript doesn't know it isn't undefined.\n\n\n      var methodCfg = config[method];\n      var options = methodCfg === true ? [] : (_a = methodCfg.options) !== null && _a !== void 0 ? _a : [];\n\n      if (options != null && !Array.isArray(options)) {\n        options = [options];\n      }\n\n      if (isValidatorOptions(method, methodCfg) && methodCfg.if) {\n        chain.if(methodCfg.if);\n      }\n\n      if (isValidatorOptions(method, methodCfg) && methodCfg.negated) {\n        chain.not();\n      }\n\n      chain[method].apply(chain, _toConsumableArray(options));\n\n      if (isValidatorOptions(method, methodCfg) && methodCfg.errorMessage) {\n        chain.withMessage(methodCfg.errorMessage);\n      }\n\n      if (isValidatorOptions(method, methodCfg) && methodCfg.bail) {\n        chain.bail();\n      }\n    });\n    return chain;\n  });\n\n  var run =\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(req) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Promise.all(chains.map(function (chain) {\n                return chain.run(req);\n              }));\n\n            case 2:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function run(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return Object.assign(chains, {\n    run: run\n  });\n}\n\nexports.checkSchema = checkSchema;\n\nfunction isValidatorOptions(method, methodCfg) {\n  return methodCfg !== true && method in chain_1.ValidatorsImpl.prototype;\n}\n\nfunction ensureLocations(config, defaults) {\n  // .filter(Boolean) is done because in can be undefined -- which is not going away from the type\n  // See https://github.com/Microsoft/TypeScript/pull/29955 for details\n  var locations = Array.isArray(config.in) ? config.in : [config.in].filter(Boolean);\n  var actualLocations = locations.length ? locations : defaults;\n  return actualLocations.filter(function (location) {\n    return validLocations.includes(location);\n  });\n}","map":{"version":3,"sources":["/home/amogha/btp/deploy/VReqST-2/VReqST-main/VReqST/frontend/client/node_modules/express-validator/src/middlewares/schema.js"],"names":["Object","defineProperty","exports","value","checkSchema","chain_1","require","check_1","validLocations","protectedNames","schema","defaultLocations","chains","keys","map","field","config","chain","check","ensureLocations","errorMessage","filter","method","includes","forEach","_a","console","warn","methodCfg","options","Array","isArray","isValidatorOptions","if","negated","not","withMessage","bail","run","req","Promise","all","assign","ValidatorsImpl","prototype","defaults","locations","in","Boolean","actualLocations","length","location"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSchema = void 0;\nconst chain_1 = require(\"../chain\");\nconst check_1 = require(\"./check\");\nconst validLocations = ['body', 'cookies', 'headers', 'params', 'query'];\nconst protectedNames = ['errorMessage', 'in'];\n/**\n * Creates an express middleware with validations for multiple fields at once in the form of\n * a schema object.\n *\n * @param schema the schema to validate.\n * @param defaultLocations\n * @returns\n */\nfunction checkSchema(schema, defaultLocations = validLocations) {\n    const chains = Object.keys(schema).map(field => {\n        const config = schema[field];\n        const chain = check_1.check(field, ensureLocations(config, defaultLocations), config.errorMessage);\n        Object.keys(config)\n            .filter((method) => {\n            return config[method] && !protectedNames.includes(method);\n        })\n            .forEach(method => {\n            var _a;\n            if (typeof chain[method] !== 'function') {\n                console.warn(`express-validator: a validator/sanitizer with name ${method} does not exist`);\n                return;\n            }\n            // Using \"!\" because typescript doesn't know it isn't undefined.\n            const methodCfg = config[method];\n            let options = methodCfg === true ? [] : (_a = methodCfg.options) !== null && _a !== void 0 ? _a : [];\n            if (options != null && !Array.isArray(options)) {\n                options = [options];\n            }\n            if (isValidatorOptions(method, methodCfg) && methodCfg.if) {\n                chain.if(methodCfg.if);\n            }\n            if (isValidatorOptions(method, methodCfg) && methodCfg.negated) {\n                chain.not();\n            }\n            chain[method](...options);\n            if (isValidatorOptions(method, methodCfg) && methodCfg.errorMessage) {\n                chain.withMessage(methodCfg.errorMessage);\n            }\n            if (isValidatorOptions(method, methodCfg) && methodCfg.bail) {\n                chain.bail();\n            }\n        });\n        return chain;\n    });\n    const run = async (req) => {\n        return await Promise.all(chains.map(chain => chain.run(req)));\n    };\n    return Object.assign(chains, { run });\n}\nexports.checkSchema = checkSchema;\nfunction isValidatorOptions(method, methodCfg) {\n    return methodCfg !== true && method in chain_1.ValidatorsImpl.prototype;\n}\nfunction ensureLocations(config, defaults) {\n    // .filter(Boolean) is done because in can be undefined -- which is not going away from the type\n    // See https://github.com/Microsoft/TypeScript/pull/29955 for details\n    const locations = Array.isArray(config.in)\n        ? config.in\n        : [config.in].filter(Boolean);\n    const actualLocations = locations.length ? locations : defaults;\n    return actualLocations.filter(location => validLocations.includes(location));\n}\n"]},"metadata":{},"sourceType":"script"}